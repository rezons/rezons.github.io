#!/usr/bin/env lua
-- vim : filetype=lua ts=2 sw=2 et :
local THE={}
local help = [[
de [OPTIONS]

Tree learner (binary splits on numerics using Gaussian approximation)
(c)2021 Tim Menzies <timm@ieee.org> MIT license.
   
OPTIONS:
  -file     X   run one test, show stackdumps on fail     = ../../data/auto93.csv
  -debug    X   run one test, show stackdumps on fail     = pass
  -h            Show help                                 = false
  -seed     X   Random number seed;                       = 10019
  -todo     X   Pass/fail tests to run at start time      = pass]]
help:gsub("\n  [-]([^%s]+)[^\n]*%s([^%s]+)", function(flag,x) 
  for n,word in ipairs(arg) do 
   if flag:match("^"..word:sub(2)..".*") then
     x= x=="true" and"false" or x=="false" and"true" or arg[n+1] end end
  if x=="true" then x=true elseif x=="false" then x=false end
  THE[flag] = tonumber(x) or x end)

THE.seed = THE.seed or 10019
if THE.h then print(help) end 
----------------------------------------------------------------------------------------
local function sort(t,f)    table.sort(t,f);   return t end
local function keys(t,   u) u={};for k,_ in pairs(t) do u[1+#u]=k     end; return u end
local function map(t,f,  u) u={};for k,v in pairs(t) do u[1+#u] =f(v) end; return u end

local function csv(f,   x,line)
  function line(x,  t)
    t={}; for y in x:gmatch"([^,]+)" do t[1+#t]=tonumber(y) or y end; return t end
  f = io.input(f) 
  return function( x) x=io.read(); if x then return line(x) else io.close(f) end end end

local function o(t,   u,key)
  function key(k) return string.format(":%s %s", k, o(t[k])) end
  if type(t) ~= "table" then return tostring(t) end
  u = #t>0 and map(t, o) or map(sort(keys(t)), key) 
  return (t._is or "").."{"..table.concat(u," ").."}" end 

local function isa(x,y) x.__index=x; return setmetatable(y,x) end 

local SAMPLE={}
function SAMPLE.new() 
  return isa(SAMPLE,{head=nil,w={},egs={},num={},sym={},goal={},ngoals=0}) end
function SAMPLE.norm(i,num,x,    lo,hi)
  lo,hi = num.lo, num.hi
  return math.abs(lo-hi)<1E-32 and 0 or (x-lo)/(hi-lo) end

function SAMPLE.better(i, eg1,eg2,smpl,   e,n,a,b,s1,s2)
  s1,s2,e,n = 0,0, 2.71828,i.ys
  for col,w in pairs(i.goal) do
    num = i.num[col]
    a  = i:norm(num, eg1.has[num.at])
    b  = i:norm(num, eg2.has[num.at])
    s1 = s1 - e^(num.w * (a-b)/n) 
    s2 = s2 - e^(num.w * (b-a)/n) end
  return s1/n < s2/n end 

function SAMPLE.add(i,eg)
  local nump,goalp,head,num1,data,skip
  function skip(x)  return x:find":" end
  function nump(x)  return not skip(x) and x:find"^[A-Z].*" end
  function goalp(x) return not skip(x) and (x:find"-" or x:find"+") end
  function top(names) 
    for n,s in pairs(names) do 
      if nump(s)  then i.num[n] = {txt=s, at=n,lo=math.huge, hi=-math.huge,
                                  w=s:find"-" and -1 or 1} 
                  else i.sym[n] = {txt=s} end
      if goalp(s) then i.ngoals=i.ngoals+1
                       i.goal[n] = s:find"-" and -1 or 1  end end end
  function num1(num,x)
    if x=="?" then return end
    if x<num.lo then num.lo=x elseif x>num.hi then num.hi=x end end
  function data(eg) 
    for n,num in pairs(i.num) do num1(num, eg[n]) end end
  if not i.head then i.head=eg; top(eg)
                else i.egs[1+#i.egs]={has=eg}; data(eg) end 
  return i end
