#!/usr/bin/env lua
-- vim : filetype=lua ts=2 sw=2 et :
local THE, help= {}, [[de OPTIONS

  -Debug     on error, dump stack and exit : false
  -dull   F  small effect= stdev*dull      : .35
  -file   S  read data from file: ../../data/auto93.csv
  -h         show help                     : false
  -p      I  distance coefficient          : 2
  -seed   I  random number seed            : 10019
  -Small  F  splits at #t^small            : .5
  -todo   S  start-up action ("all"=do all): pass ]]

local function eden()  
  help:gsub("\n  [-]([^%s]+)[^\n]*%s([^%s]+)", function(flag,x) 
    for n,word in ipairs(arg) do 
      if flag:match("^"..word:sub(2)..".*") then 
        x = x == "false" and "true" or arg[n+1] end end
    THE[flag] = tonumber(x) or x end) end

eden(help)
if THE.h then print(help) end
----------------------------------------------------------------------------------------
local b4={}; for k,_ in pairs(_ENV) do b4[k]=k end
local function rogues()
  for k,v in pairs(_ENV) do if not b4[k] then print("Rogue?",k,type(v)) end end end

local function sort(t,f)    table.sort(t,f);   return t end
local function keys(t,   u) u={};for k,_ in pairs(t) do u[1+#u]=k     end; return u end
local function map(t,f,  u) u={};for k,v in pairs(t) do u[1+#u] =f(v) end; return u end

local function csv(file,   x,line)
  function line(x,  t)
    t={}; for y in x:gmatch"([^,]+)" do t[1+#t]=tonumber(y) or y end; return t end
   file = io.input(file) 
   return function() x=io.read(); if x then return line(x) else io.close(file) end end end

local function o(t,   u,key)
  function key(k) return string.format(":%s %s", k, o(t[k])) end
  if type(t) ~= "table" then return tostring(t) end
  return "{"..table.concat(#t>0 and map(t,o) or map(sort(keys(t)),key)," ").."}" end 

local function rand(lo,hi)
  THE.seed = (16807 * THE.seed) % 2147483647
  return (lo or 0) + ((hi or 1) - (lo or 0)) * THE.seed / 2147483647 end

local function randi(lo,hi) return math.floor(0.5 + rand(lo,hi)) end
local function any(t) return t[randi(1,#t)] end
local function shuffle(t,   j)
  for i=#t,2,-1 do j=randi(1,i); t[i],t[j]=t[j],t[i] end; return t end

local function new(mt,x) return setmetatable(x,mt) end
local function klass(s, klass)
  klass = {_is=s, __tostring=o}
  klass.__index = klass
  return new({__call=function(_,...) return klass.new(...) end},klass) end

----------------------------------------------------------------------------------------
local NUM=klass"NUM"
function NUM.new(n,s)  
  return new(NUM, {txt=s or"", at=n or 0,lo=math.huge, hi=-math.huge, 
                   w=(s or ""):find"-" and -1 or 1}) end

function NUM.add(i,x)  
  if x ~= "?" then i.hi=math.max(i.hi,x); i.lo=math.min(i.lo,x) end end

function NUM.norm(i,x)
  return math.abs(i.lo - i.hi) < 1E-32 and 0 or (x - i.lo) / (i.hi - i.lo) end

----------------------------------------------------------------------------------------
local EG=klass"EG"
function EG.new(t) return new(EG, {has=t}) end

function EG.dist(i,j,smpl,   a,b,d,n,inc,dist1)
  function dist1(num,a,b)
    if   num 
    then if     a=="?" then num:norm(b); a=b>.5 and 0 or 1
         elseif b=="?" then num:norm(a); b=a>.5 and 0 or 1
         else   a,b = num:norm(a), num:norm(b) end
         return math.abs(a-b) 
    else return a==b and 0 or 1 end
  end
  d, n = 0, 1E-31
  for col,_ in pairs(smpl.xs) do
    a,b = i.has[col], j.has[col]
    inc = a=="?" and b=="?" and 1 or dist1(smpl.num[col],a,b)
    d   = d + inc^THE.p
    n   = n + 1 end
  return (d/n)^(1/THE.p) end

function EG.better(eg1,eg2,smpl,    num,e,n,a,b,s1,s2)
  s1,s2,e,n = 0,0,2.71828,#smpl.nys
  for col,_ in pairs(smpl.ys) do
    num = smpl.num[col]
    a   = num:norm(eg1.has[col])
    b   = num:norm(eg2.has[col])
    s1  = s1 - e^(num.w * (a-b)/n) 
    s2  = s2 - e^(num.w * (b-a)/n) end
  return s1/n < s2/n end 

----------------------------------------------------------------------------------------
local SAMPLE=klass"SAMPLE"
function SAMPLE.new() 
  return new(SAMPLE, {head=nil,w={},egs={},num={},sym={},xs={},ys={},nys=0}) end

function SAMPLE.skip(i,x)  return x:find":" end
function SAMPLE.nump(i,x)  return not i:skip(x) and x:find"^[A-Z].*" end
function SAMPLE.goalp(i,x) return not i:skip(x) and (x:find"-" or x:find"+") end

function SAMPLE.add(i,eg)
  if   not i.head 
  then i.head = eg
       for n,s in pairs(eg) do 
         if i:goalp(s) then i.ys[n]  = s; i.nys = 1+i.nys
                       else i.xs[n]  = s end  
         if i:nump(s)  then i.num[n] = NUM(n,s)
                       else i.sym[n] = {txt=s} end end
  else i.egs[1+#i.egs] = Row.new(eg); 
       for n,num in pairs(i.num) do num:add(eg[n]) end end 
  return i end

function SAMPLE.far(i,eg1,egs,    dist,tmp)
  dist = function(eg2) return {eg2,eg1:dist(eg2,i)} end
  tmp  = sort(map(egs, dist), function(a,b) return a[2] < b[2] end)
  return tmp[#tmp*THE.far//1] end

function SAMPLE.label(i, egs,n,one,    egs,n,one,two,a,b,c,lo,hi)
  egs,n = egs or i.egs, 1
  for _,eg in pairs(egs) do eg.klass= n end
  if #egs < 2*#i.egs^THE.epsilon then return end
  one   = one or i:far(any(egs),egs)
  two,c = i:far(one, egs)
  for _eg in pairs(egs) do
    a = eg:dist(one, i)
    b = eg:dist(two, i)
    eg.x = (a^2 + c^2 - b^2)/(2*c) 
  end
  lo,hi = {},{}
  for n,eg in pairs(sort(egs,function(a,b) return a.x < b.x end)) do
    table.insert(n <= .5*#egs and lo or hi, eg) end
  i:label(one:better(two,i) and lo or hi, n*2, two) end 

----------------------------------------------------------------------------------------
local fails=0
local function asserts(test,msg) 
  if not test then 
    fails=fails+1; print("!!!! FAIL",msg)
    if THE.debug then assert(test,msg) else  print("!!!! FAIL",msg) end end end

local go={}
function go.sample(s) s=SAMPLE() print(o(s)) end
rogues()
os.exit(fails)
