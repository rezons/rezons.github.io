#!/usr/bin/env lua
-- vim : filetype=lua ts=2 sw=2 et :
local THE={}
local help = [[
de [OPTIONS]

Tree learner (binary splits on numerics using Gaussian approximation)
(c)2021 Tim Menzies <timm@ieee.org> MIT license.
   
OPTIONS:
  -file     X   run one test, show stackdumps on fail     = ../../data/auto93.csv
  -debug    X   run one test, show stackdumps on fail     = pass
  -h            Show help                                 = false
  -seed     X   Random number seed;                       = 10019
  -todo     X   Pass/fail tests to run at start time      = pass]]
help:gsub("\n  [-]([^%s]+)[^\n]*%s([^%s]+)", function(flag,x) 
  for n,word in ipairs(arg) do 
   if flag:match("^"..word:sub(2)..".*") then
     x= x=="true" and"false" or x=="false" and"true" or arg[n+1] end end
  THE[flag] = tonumber(x) or x end)

t.seed = t.seed or 10019
if t.h then print(help) end 
----------------------------------------------------------------------------------------
local function sort(t,f)    table.sort(t,f);   return t end
local function keys(t,   u) u={};for k,_ in pairs(t) do u[1+#u]=k     end; return u end
local function map(t,f,  u) u={};for k,v in pairs(t) do u[1+#u] =f(v) end; return u end

local function csv(f,   x,line)
  function line(x,  t)
    t={}; for y in x:gmatch"([^,]+)" do t[1+#t]=tonumber(y) or y end; return t end
  f = io.input(f) 
  return function( x) x=io.read(); if x then return line(x) else io.close(f) end end end

local function o(t,   u,key)
  function key(_,k) return string.format(":%s %s", k, o(t[k])) end
  if type(t) ~= "table" then return tostring(t) end
  u = #t>0 and map(t, o) or map(sort(keys(t)), key) 
  return (t._is or "").."{"..table.concat(u," ").."}" end 

function norm(i,x)
  return math.abs(i.lo-i.hi)<1E-32 and 0 or (x-i.lo)/(i.hi-i.lo) end

function better(i,j,smpl,   e,n,a,b,s1,s2)
  s1,s2,e,n = 0,0, 2.71828,smpl.ys
  for goal,w in pairs(smpl.goal) do
    num = smpl.num[goal]
    a  = norm(num, i.has[num.at])
    b  = norm(num, j.has[num.at])
    s1 = s1 - e^(num.w * (a-b)/n) 
    s2 = s2 - e^(num.w * (b-a)/n) end
  return s1/n < s2/n end 

function sample(i,eg)
  local nump,goalp,head,num1,data,skip
  i = i or {head=nil,w={},egs={},num={},sym={},goal={},ngoals=0}
  function skip(x)  return x:find":" end
  function nump(x)  return not skip(x) and x:find"^[A-Z].*" end
  function goalp(x) return not skip(x) and (x:find"-" or x:find"+") end
  function top(names) 
    for n,s in pairs(names) do 
      if nump(s)  then i.num[n] = {txt=s, at=n,lo=math.huge, hi=-math.huge,
                                  w=s:find"-" and -1 or 1} 
                  else i.sym[n] = {txt=s} end
      if goalp(s) then ngoals=ngoals+1
                       i.goal[n] = s:find"-" and -1 or 1  end end end
  function num1(num,x)
    if x=="?" then return end
    if x<num.lo then num.lo=x elseif x>num.hi then num.hi=x end end
  function data(eg) 
    for n,num in pairs(i.num) do num1(num, eg[n]) end end
  if i.head then data(eg); i.egs[1+#i.egs]={has=eg} else top(eg); i.head=eg end 
  return i end
