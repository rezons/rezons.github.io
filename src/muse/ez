#!/usr/bin/env lua
-- vim : filetype=lua ts=2 sw=2 et :

local THE={file="../../data/auto93.csv",
           seed=10019}

local randi,rand
function randi(lo,hi) return math.floor(0.5 +rand(lo,hi)) end
function rand(lo,hi,     mult,mod) 
  lo, hi = lo or 0, hi or 1
  THE.seed = (16807 * THE.seed) % 2147483647
  return lo + (hi-lo) * THE.seed / 2147483647 end

local fmt,red,green,yellow
fmt = string.format
function red(s)    return fmt("\27[1m\27[%sm%s\27[0m",31,s) end
function green(s)  return fmt("\27[1m\27[%sm%s\27[0m",32,s) end
function yellow(s) return fmt("\27[1m\27[%sm%s\27[0m",33,s) end

local cat,push,sort,map,keys
cat = table.concat
function push(t,x) table.insert(t,x); return x end
function sort(t,f) table.sort(t,f);   return t end
function map(t,f,  u) u={};for k,v in pairs(t) do u[1+#u] =f(v)   end; return u       end
function keys(t,   u) u={};for k,_ in pairs(t) do u[1+#u]=k       end; return sort(u) end

local out,o
function out(x) print(o(x)) end
function o(t,  u)
  function fun1(x) return o(x) end
  function fun2(k) return fmt(":%s %s",yellow(k), o(t[k])) end
  return type(t) ~= "table" and tostring(t) or
    red("{")..cat(#t>0 and map(t,fun1) or map(keys(t),fun2) ,", ")..red("}") end

-- function has(mt,x) return setmetatable(x,mt) end
-- function lib.obj(s, self)
--    self = {_is=s} 
--    self.__index = self
--    return has({__call = function(_,...) return self.new(...) end},self) end

local function csv(file,   x,coerce,line)
  function coerce(x)
    if x=="true" then return true elseif x=="false" then return false end
    return tonumber(x) or x end
  function line(x,  t)
    t={}; for y in x:gsub("[\t ]*",""):gmatch"([^,]+)" do push(t,coerce(y)) end
    return t end
  file = io.input(file) 
  return function(   x)
    x = io.read()
    if x then return line(x) else io.close(file) end end end

local ok,per,sd,median
function median(num)  return per(num, .5) end
function sd(num)      return math.abs(per(num,.9) - per(num,.1))/ 2.56 end
function per(num,p,t) t=has(num); p=p*#t//1; return t[p<1 and 1 or p] end
function norm(num,x)
  local lo,hi=num.lo, num.hi
  return x=="?" and x or abs(hi - lo) < 1E-9 and 0 or (x - lo)/(hi - lo) end
function has(num) 
  if not num.ok then table.sort(num.has); num.ok=true; end
  return num.has end

local function ent(i,   e,n)
  n=0; for _,v in pairs(i.has) do n = n+v end
  e=0; for _,v in pairs(i.has) do e = e- v/n * math.log(v/n,2) end
  return e end

local sample={}
function sample.clone(i,inits,    j)
  j= sample(i.names)
  for _,eg in pairs(inits or {}) do i=sample.add(i,eg) end; return i end

function sample.add(i, eg)
  local sym1,num1,data,headers
  i=i or setmetatable({w={}, nums={},syms={},ys={},xs={},egs={}},sanple)
  eg = eg.cells and eg.cells or eg
  function sym1(sym,x)
    if x~="?" then
      sym.has[x] = 1 + (sym.has[x] or 0)
      if sym.has[x] > sym.most then sym.mode, sym.most=x,sym.has[x] end end end
  function num1(num,x)
    if x~="?" then
      push(num.has,x)
      num.ok = fakse
      num.lo = math.min(num.lo, x) 
      num.hi = math.max(num.hi, x) end end
  function data(eg)
    for k,v in pairs(i.nums) do num1(v, eg[v]) end 
    for k,v in pairs(i.syms) do sym1(v, eg[v]) end 
    push(i.egs,{cells=eg}) end
  function headers(eg)
    for k,v in pairs(eg) do 
      if not v:find":" then
        if v:find"+" or v:find"-" then i.ys[k]=v else i.xs[k]=v end 
        if v:find"^[A-Z]" then 
           local w = v:find"-" and 1 or -1
           i.nums[k]={has={},ok=false,w=w, lo=math.huge, hi=-math.huge} 
        else 
           i.syms[k]={has={},mode=0,most=0} end end end 
     return eg end 
  if i.names then data(eg) else i.names = headers(eg) end
  return i end

function sample.dist(i,eg1,eg2)
  local d,n,inc,sym1,num1 = 0,1E-9
  function sym1(a,b) return a=="?" and b=="?" and 1 or a==b and 0 or 1 end 
  function num1(a,b)
    if     a=="?" and b=="?" then return 1 
    elseif a=="?"            then a = b>.5 and 0 or 1
    elseif b=="?"            then b = a>.5 and 0 or 1 end
    return math.abs(a-b) end 
  for k,_ in pairs(i.xs) do 
    if i.num[k] then
      inc=  num1(norm(num,eg1.cells[k]), norm(num,eg2.cells[k])) 
    else
      inc=  sym1(eg.cells[k], eg2.cells[k]) end 
    d = d+ inc^THE.p
    n = n + 1 end 
  return (d/n)^(1/THE.p) end
   
function SAMPLE:neighbors(eg1,egs,cols,        dist_eg2)
  dist_eg2 = function(_,eg2) return {eg1:dist(eg2,cols or self.cols.xs),eg2} end
  return sort(map(egs or self.egs,dist_eg2),ones) end

function SAMPLE:distance_farEg(eg1,egs,cols,    tmp)
  tmp = self:neighbors(eg1, egs, cols)
  tmp = tmp[#tmp*THE.Far//1]
  return tmp[2], tmp[1] end


